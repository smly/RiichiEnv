const fs = require('fs');
const path = require('path');
const { optimize } = require('svgo');

const TILES_DIR = path.join(__dirname, '..', 'riichienv-mahjong-tiles-regular');
const OUTPUT_FILE = path.join(__dirname, '..', 'src', 'tiles.ts');

if (!fs.existsSync(TILES_DIR)) {
    console.error(`Error: Tiles directory not found at ${TILES_DIR}`);
    console.error("Please ensure the 'riichienv-mahjong-tiles-regular' directory exists in the project root.");
    process.exit(1);
}

const mapFileNameToId = (filename) => {
    // Map FluffyStuff filenames to our IDs (or MJAI style strings)
    // MJAI: 1m, 2m... 5mr (red 5), 1p... 1s... 1z..7z
    // FluffyStuff: Man1.svg... Man5-Dora.svg... Pin1... Sou1... Ton, Nan, Shaa, Pei, Haku, Hatsu, Chun

    const name = path.basename(filename, '.svg');

    if (name === 'Back') return 'back';
    if (name === 'Blank') return 'blank';
    if (name === 'Front') return 'front';

    const suits = { 'Man': 'm', 'Pin': 'p', 'Sou': 's' };

    for (const [prefix, suffix] of Object.entries(suits)) {
        if (name.startsWith(prefix)) {
            const rest = name.slice(prefix.length); // "1", "5", "5-Dora"
            if (rest.includes('-Dora')) {
                return '5' + suffix + 'r';
            }
            return rest + suffix;
        }
    }

    const honors = {
        'Ton': 'E', 'Nan': 'S', 'Shaa': 'W', 'Pei': 'N',
        'Haku': 'P', 'Hatsu': 'F', 'Chun': 'C'
    };

    if (honors[name]) {
        return honors[name];
    }

    return null;
};

const main = () => {
    const files = fs.readdirSync(TILES_DIR).filter(f => f.endsWith('.svg'));
    const tileMap = {};

    files.forEach(file => {
        const id = mapFileNameToId(file);
        if (id) {
            let content = fs.readFileSync(path.join(TILES_DIR, file), 'utf8');

            // SVGO might fail if it finds xlink:href without the namespace declaration
            if (content.includes('xlink:href') && !content.includes('xmlns:xlink')) {
                content = content.replace('<svg', '<svg xmlns:xlink="http://www.w3.org/1999/xlink"');
            }

            // Manual cleaning instead of SVGO to avoid breaking complex Inkscape transforms
            // 1. Remove XML declaration and comments
            content = content.replace(/<\?xml.*?\?>/gs, '');
            content = content.replace(/<!--.*?-->/gs, '');

            // 2. Remove metadata and namedview
            content = content.replace(/<metadata.*?>.*?<\/metadata>/gs, '');
            content = content.replace(/<sodipodi:namedview.*?>.*?<\/sodipodi:namedview>/gs, '');
            content = content.replace(/<rdf:RDF.*?>.*?<\/rdf:RDF>/gs, '');

            // 3. Remove namespaced attributes (Inkscape, Sodipodi, etc.) but keep xmlns and viewBox
            content = content.replace(/\s\w+:[^=]+="[^"]*"/g, (match) => {
                if (match.includes('xlink:href')) return match;
                if (match.includes('viewBox')) return match;
                return '';
            });

            // 4. Remove explicit width/height to allow CSS scaling
            content = content.replace(/<svg\s+([^>]*?)width="[^"]*"/g, '<svg $1');
            content = content.replace(/<svg\s+([^>]*?)height="[^"]*"/g, '<svg $1');

            // Extra cleaning to ensure it's as flat as possible
            if (content) {
                content = content.replace(/\s+/g, ' ').trim();
                tileMap[id] = content;
            }
        }
    });

    // Alias 0m/0p/0s to red tiles if they exist
    if (tileMap['5mr']) tileMap['0m'] = tileMap['5mr'];
    if (tileMap['5pr']) tileMap['0p'] = tileMap['5pr'];
    if (tileMap['5sr']) tileMap['0s'] = tileMap['5sr'];

    const outputContent = `// Auto-generated by scripts/gen_tiles.js
export const TILES: Record<string, string> = ${JSON.stringify(tileMap)};
`;

    fs.writeFileSync(OUTPUT_FILE, outputContent);
    console.log(`Generated ${OUTPUT_FILE} with ${Object.keys(tileMap).length} tiles.`);
};

main();
